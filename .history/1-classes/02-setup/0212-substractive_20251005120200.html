<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hyperphone — Subtractive Synth (Wireframe v4)</title>
<style>
  :root{ --bg:#000; --wire:rgba(255,255,255,.9); --fill:rgba(255,255,255,.65); }
  html,body{height:100%;margin:0;background:var(--bg);color:transparent;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;overflow:hidden;-webkit-user-select:none;user-select:none}

  /* Toolbar: wireframe only, no text */
  header{display:flex;gap:8px;align-items:center;padding:6px 8px;background:transparent;position:sticky;top:0;z-index:10}
  .chip,.btn{background:transparent;color:transparent;padding:0;border:none;cursor:pointer;position:relative}
  .chip{width:20px;height:20px}
  .btn{width:28px;height:28px}
  .chip::after,.btn::after{content:"";position:absolute;inset:0;border:1px solid var(--wire)}
  .chip[aria-pressed="true"]::after{box-shadow:0 0 0 2px var(--wire) inset}

  /* FLEX fullscreen canvas; slots fill gaps */
  .grid{display:flex;flex-wrap:wrap;gap:8px;padding:8px;height:calc(100% - 44px);align-content:stretch}
  .panel{background:transparent;border:none;padding:0;display:flex;flex-direction:column;gap:8px;min-width:110px;min-height:110px;flex:1 1 calc(25% - 8px)}

  /* Wireframe controls */
  .topbar{display:flex;gap:8px;flex-wrap:wrap;align-items:stretch}
  .keyshelf{display:flex;gap:8px;flex-wrap:wrap}

  .keybtn{width:72px;height:72px;border:none;background:transparent;cursor:pointer;position:relative;color:transparent}
  .keybtn::after{content:"";position:absolute;inset:0;border:1px solid var(--wire)}
  .keybtn.active::after{box-shadow:0 0 12px var(--wire),0 0 0 2px var(--wire) inset}

  /* Vertical square sliders with fill */
  .vslider{--val:0%;position:relative;width:72px;height:72px}
  .vslider::after{content:"";position:absolute;inset:0;border:1px solid var(--wire)}
  .vslider .fill{position:absolute;left:0;bottom:0;width:100%;height:var(--val);background:var(--fill)}

  /* Meter (wireframe) */
  .meter{height:6px;background:transparent;position:relative;width:220px}
  .meter::after{content:"";position:absolute;inset:0;border:1px solid var(--wire)}
  .meter>div{height:100%;width:0%;background:var(--fill)}

 
  /* Right-edge VU line */
  #vuLine{
    position:fixed; top:0; right:0;
    width:1px; height:100vh;
    background:transparent; z-index:9999;
  }
  #vuLine .fill{
    position:absolute; bottom:0; right:0;
    width:1px; height:100%;
    background:#00ff00;              /* green */
    transform-origin:bottom; transform:scaleY(0);
  }

</style>
</head>
<body>
  <header>
    <div class="row" id="divisionBar" title="Shift+1..8 — switch divisions"></div>
    <button id="fullscreenBtn" class="btn" title="Toggle Fullscreen (double‑click anywhere)"></button>
  </header>

  <main class="grid" id="grid" title="Workspace"></main>
  <div id="vuLine"><div class="fill"></div></div>

<script>
/***************************
 * AUDIO ENGINE PRIMITIVES *
 ***************************/
let audioCtx; let masterGain; let analyser; let meterRAF;
async function ensureAudio(){
  if(audioCtx && audioCtx.state!=='closed'){ if(audioCtx.state==='suspended') await audioCtx.resume(); return; }
  audioCtx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
  masterGain = audioCtx.createGain(); masterGain.gain.value=0.9;
  analyser = audioCtx.createAnalyser(); analyser.fftSize=2048;
  masterGain.connect(analyser).connect(audioCtx.destination);
}
function createWhiteNoiseBuffer(ctx){
  const length = ctx.sampleRate*2; const buffer=ctx.createBuffer(2,length,ctx.sampleRate);
  for(let ch=0; ch<2; ch++){ const data=buffer.getChannelData(ch); for(let i=0;i<length;i++){ data[i]=Math.random()*2-1; } }
  return buffer;
}
function makeNoiseSource(){
  const source=audioCtx.createBufferSource(); source.buffer=createWhiteNoiseBuffer(audioCtx); source.loop=true; const trim=audioCtx.createGain(); trim.gain.value=1; source.connect(trim); return {source,outlet:trim};
}
function makeADSR({attack=.01,decay=.1,sustain=.7,release=.2}={}){
  const vca=audioCtx.createGain(); vca.gain.value=0;
  const gateOn=()=>{ const now=audioCtx.currentTime; vca.gain.cancelScheduledValues(now); vca.gain.setValueAtTime(vca.gain.value,now); vca.gain.linearRampToValueAtTime(1, now+attack); vca.gain.linearRampToValueAtTime(sustain, now+attack+decay); };
  const gateOff=()=>{ const now=audioCtx.currentTime; vca.gain.cancelScheduledValues(now); vca.gain.setValueAtTime(vca.gain.value,now); vca.gain.linearRampToValueAtTime(0, now+release); };
  return {node:vca, gateOn, gateOff};
}
function makeFilter({type='lowpass',cutoff=1200,Q=0.0001}={}){ const biq=audioCtx.createBiquadFilter(); biq.type=type; biq.frequency.value=cutoff; biq.Q.value=Q; return biq; }

function wireSimpleMeter(barEl){ /* legacy per-panel meter now unused */ }

function startVuLine(){
  if(!analyser) return;
  const fill = document.querySelector('#vuLine .fill');
  const data = new Uint8Array(analyser.fftSize);
  (function loop(){
    analyser.getByteTimeDomainData(data);
    let sum=0; for(let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum+=v*v; }
    const rms = Math.sqrt(sum/data.length);
    const scale = Math.min(1, rms * 2.5);
    fill.style.transform = `scaleY(${scale})`;
    requestAnimationFrame(loop);
  })();
}

/***********************
 * UI / LAYOUT CONTROL *
 ***********************/
const grid=document.getElementById('grid');
const divisionBar=document.getElementById('divisionBar');
const fullscreenBtn=document.getElementById('fullscreenBtn');
let currentDivisions=3; // default
let globalSliderList=[]; // ordered sliders for Q-row control (vertical squares)

// build chips 1..8
for(let n=1;n<=8;n++){ const chip=document.createElement('button'); chip.className='chip'; chip.title=`Set divisions: ${n}`; chip.setAttribute('aria-pressed', String(n===currentDivisions)); chip.addEventListener('click',()=>setDivisions(n)); divisionBar.appendChild(chip); }

function setDivisions(n){
  currentDivisions=n; [...divisionBar.querySelectorAll('.chip')].forEach((c,i)=>c.setAttribute('aria-pressed', String(i+1===n)));
  renderPanels(n);
  // haptic mosaic sizing using flex-basis
  const children=[...grid.children];
  const cols=Math.min(4,n);
  children.forEach((el,i)=>{ el.style.order=i; el.style.flexBasis = `calc(${100/cols}% - 8px)`; });
  if([3,5,6,7].includes(n)){
    children.forEach((el,i)=>{
      if(n===3 && i===1){ el.style.flexBasis='calc(50% - 8px)'; }
      if(n===5 && (i===0||i===3)){ el.style.flexBasis='calc(50% - 8px)'; }
      if(n===6 && (i===2||i===5)){ el.style.flexBasis='calc(50% - 8px)'; }
      if(n===7 && (i===1||i===4)){ el.style.flexBasis='calc(50% - 8px)'; }
    });
  }
}

fullscreenBtn.addEventListener('click', toggleFullscreen); addEventListener('dblclick', toggleFullscreen);
function toggleFullscreen(){ if(!document.fullscreenElement){ document.documentElement.requestFullscreen?.(); } else { document.exitFullscreen?.(); } }

/****************
 * PANEL RENDER *
 ****************/
function renderPanels(n){
  grid.innerHTML=''; globalSliderList=[];
  for(let i=1;i<=n;i++){
    const panel=document.createElement('section'); panel.className='panel'; panel.title=`Lesson ${i}`;
    const content=buildLesson(i);
    const topbar=document.createElement('div'); topbar.className='topbar';
    const keyshelf=document.createElement('div'); keyshelf.className='keyshelf';
    content.controls.querySelectorAll('.slider').forEach(s=>topbar.appendChild(s));
    [...content.controls.childNodes].forEach(n=>{ if(!topbar.contains(n)) keyshelf.appendChild(n); });
    replaceNativeRanges(topbar);
    panel.append(topbar,keyshelf);
    if(i===1){ const meter=document.createElement('div'); meter.className='meter'; const fill=document.createElement('div'); meter.appendChild(fill); meter.title='Output level'; panel.appendChild(meter); content.onFirstStart=()=>wireSimpleMeter(fill); }
    grid.appendChild(panel);
  }
}

/***********************
 * LESSON DEFINITIONS  *
 ***********************/
function buildLesson(idx){
  switch(idx){
    case 1: return lesson1_basicNoise();
    case 2: return lesson2_lowpassAndTwoKeys();
    case 3: return lesson3_adsrEnvelope();
    case 4: return lesson4_lfoOnCutoff();
    case 5: return stubLesson('Multimode filter & resonance sweep');
    case 6: return stubLesson('Serial vs parallel filtering (HP+LP)');
    case 7: return stubLesson('Noise color morphing (white/pink/brown)');
    case 8: return stubLesson('Keyboard mapping + touch velocity');
    default: return stubLesson('Coming next');
  }
}
function stubLesson(title){ const controls=document.createElement('div'); controls.className='controls'; return {desc:title, controls}; }

// L1 — Basic white noise (press&hold)
function lesson1_basicNoise(){
  const controls=document.createElement('div'); controls.className='controls';
  const bigKey=document.createElement('button'); bigKey.className='keybtn'; bigKey.title='L1 — Space: hold for noise';
  let started=false; let current=null; function startNoise(){ ensureAudio().then(()=>{ if(!started){ started=true; lesson1.onFirstStart && lesson1.onFirstStart(); } if(current) return; const {source,outlet}=makeNoiseSource(); outlet.connect(masterGain); source.start(); current={source,outlet}; bigKey.classList.add('active'); }); }
  function stopNoise(){ if(!current) return; try{current.source.stop();}catch{} current.outlet.disconnect(); current=null; bigKey.classList.remove('active'); }
  bigKey.addEventListener('mousedown',startNoise); bigKey.addEventListener('mouseup',stopNoise); bigKey.addEventListener('mouseleave',stopNoise);
  bigKey.addEventListener('touchstart',(e)=>{e.preventDefault();startNoise();},{passive:false}); bigKey.addEventListener('touchend',stopNoise);
  addEventListener('keydown',(e)=>{ if(e.code==='Space') startNoise(); }); addEventListener('keyup',(e)=>{ if(e.code==='Space') stopNoise(); });
  const wrap=document.createElement('div'); wrap.className='controls'; wrap.appendChild(bigKey);
  return (window.lesson1={desc:'Press and hold to emit white noise', controls:wrap, onFirstStart:null});
}

// L2 — Lowpass + compare two triggers (A darker / S brighter)
function lesson2_lowpassAndTwoKeys(){
  const controls=document.createElement('div'); controls.className='controls';
  const keyA=document.createElement('button'); keyA.className='keybtn'; keyA.title='L2 — A: Lowpass noise (darker)';
  const keyS=document.createElement('button'); keyS.className='keybtn'; keyS.title='L2 — S: Lowpass noise (brighter)';
  const cutoff=sliderKV('Cutoff',{min:100,max:8000,step:1,value:1200}); cutoff.wrap.title='Cutoff';
  const q=sliderKV('Resonance',{min:0.0001,max:30,step:0.0001,value:0.0001}); q.wrap.title='Resonance';
  let activeA=null, activeS=null;
  function trigger(which, brighter){ ensureAudio().then(()=>{ const {source,outlet}=makeNoiseSource(); const lp=makeFilter({type:'lowpass', cutoff: brighter ? Math.max(1500, parseFloat(cutoff.input.value)*2) : parseFloat(cutoff.input.value), Q: parseFloat(q.input.value)}); outlet.connect(lp).connect(masterGain); source.start(); if(which==='A'){activeA={source,outlet,lp}; keyA.classList.add('active');} else {activeS={source,outlet,lp}; keyS.classList.add('active');} }); }
  function release(which){ const act=(which==='A')?activeA:activeS; if(!act) return; try{act.source.stop();}catch{} act.outlet.disconnect(); act.lp.disconnect(); if(which==='A'){activeA=null; keyA.classList.remove('active');} else {activeS=null; keyS.classList.remove('active');} }
  keyA.addEventListener('mousedown',()=>trigger('A',false)); keyA.addEventListener('mouseup',()=>release('A')); keyA.addEventListener('mouseleave',()=>release('A'));
  keyA.addEventListener('touchstart',(e)=>{e.preventDefault();trigger('A',false)},{passive:false}); keyA.addEventListener('touchend',()=>release('A'));
  keyS.addEventListener('mousedown',()=>trigger('S',true)); keyS.addEventListener('mouseup',()=>release('S')); keyS.addEventListener('mouseleave',()=>release('S'));
  keyS.addEventListener('touchstart',(e)=>{e.preventDefault();trigger('S',true)},{passive:false}); keyS.addEventListener('touchend',()=>release('S'));
  addEventListener('keydown',(e)=>{ if(e.repeat) return; const k=e.key.toLowerCase(); if(k==='a') trigger('A',false); if(k==='s') trigger('S',true); });
  addEventListener('keyup',(e)=>{ const k=e.key.toLowerCase(); if(k==='a') release('A'); if(k==='s') release('S'); });
  cutoff.oninput(()=>{ if(activeA) activeA.lp.frequency.value=+cutoff.input.value; if(activeS) activeS.lp.frequency.value=Math.max(1500, +cutoff.input.value*2); });
  q.oninput(()=>{ if(activeA) activeA.lp.Q.value=+q.input.value; if(activeS) activeS.lp.Q.value=+q.input.value; });
  const wrap=document.createElement('div'); wrap.className='controls'; wrap.append(keyA,keyS,cutoff.wrap,q.wrap); return {desc:'Lesson 2', controls:wrap};
}

// L3 — ADSR envelope on amplitude (D to gate)
function lesson3_adsrEnvelope(){
  const controls=document.createElement('div'); controls.className='controls';
  const keyD=document.createElement('button'); keyD.className='keybtn'; keyD.title='L3 — D: Gate with ADSR';
  const A=sliderKV('Attack',{min:0.001,max:1.0,step:0.001,value:0.02}); A.wrap.title='Attack';
  const D=sliderKV('Decay', {min:0.001,max:2.0,step:0.001,value:0.2}); D.wrap.title='Decay';
  const S=sliderKV('Sustain',{min:0.0,max:1.0,step:0.001,value:0.6}); S.wrap.title='Sustain';
  const R=sliderKV('Release',{min:0.001,max:2.0,step:0.001,value:0.3}); R.wrap.title='Release';
  const cutoff=sliderKV('LP Cutoff',{min:200,max:8000,step:1,value:1800}); cutoff.wrap.title='LP Cutoff';
  let env, active=null;
  function gateOn(){ ensureAudio().then(()=>{ if(active) return; const {source,outlet}=makeNoiseSource(); const lp=makeFilter({type:'lowpass',cutoff:+cutoff.input.value,Q:0.0001}); env=makeADSR({attack:+A.input.value,decay:+D.input.value,sustain:+S.input.value,release:+R.input.value}); outlet.connect(lp).connect(env.node).connect(masterGain); source.start(); env.gateOn(); active={source,outlet,lp}; keyD.classList.add('active'); }); }
  function gateOff(){ if(!active) return; env.gateOff(); const stopAt=audioCtx.currentTime + +R.input.value + 0.05; active.source.stop(stopAt); setTimeout(()=>{ try{active.outlet.disconnect(); active.lp.disconnect();}catch{} active=null; keyD.classList.remove('active'); }, (+R.input.value+0.1)*1000); }
  keyD.addEventListener('mousedown',gateOn); keyD.addEventListener('mouseup',gateOff); keyD.addEventListener('mouseleave',gateOff);
  keyD.addEventListener('touchstart',(e)=>{e.preventDefault();gateOn();},{passive:false}); keyD.addEventListener('touchend',gateOff);
  addEventListener('keydown',(e)=>{ if(e.repeat) return; if(e.key.toLowerCase()==='d') gateOn(); }); addEventListener('keyup',(e)=>{ if(e.key.toLowerCase()==='d') gateOff(); });
  cutoff.oninput(()=>{ if(active) active.lp.frequency.value=+cutoff.input.value; });
  const wrap=document.createElement('div'); wrap.className='controls'; wrap.append(keyD,A.wrap,D.wrap,S.wrap,R.wrap,cutoff.wrap); return {desc:'Lesson 3', controls:wrap};
}

// L4 — LFO modulating filter cutoff (F toggles)
function lesson4_lfoOnCutoff(){
  const controls=document.createElement('div'); controls.className='controls';
  const play=document.createElement('button'); play.className='keybtn'; play.title='L4 — F: Toggle LFO on cutoff';
  const rate=sliderKV('LFO Rate',{min:0.1,max:20,step:0.01,value:5}); rate.wrap.title='LFO Rate';
  const depth=sliderKV('Depth',{min:50,max:6000,step:1,value:1200}); depth.wrap.title='Depth';
  const baseCut=sliderKV('Base Cutoff',{min:100,max:8000,step:1,value:800}); baseCut.wrap.title='Base Cutoff';
  controls.append(play, rate.wrap, depth.wrap, baseCut.wrap);
  let active=null, lfoOsc=null, lfoGain=null, lp=null;
  function start(){ ensureAudio().then(()=>{ if(active) return; const {source,outlet}=makeNoiseSource(); lp=makeFilter({type:'lowpass',cutoff:+baseCut.input.value,Q:.0001}); lfoOsc=audioCtx.createOscillator(); lfoOsc.type='sine'; lfoOsc.frequency.value=+rate.input.value; lfoGain=audioCtx.createGain(); lfoGain.gain.value=+depth.input.value; lfoOsc.connect(lfoGain).connect(lp.frequency); outlet.connect(lp).connect(masterGain); lfoOsc.start(); source.start(); active={source,outlet}; play.classList.add('active'); }); }
  function stop(){ if(!active) return; try{active.source.stop(); lfoOsc.stop();}catch{} try{active.outlet.disconnect(); lp.disconnect(); lfoGain.disconnect();}catch{} active=null; lfoOsc=null; lfoGain=null; lp=null; play.classList.remove('active'); }
  play.addEventListener('mousedown',()=> active?stop():start()); play.addEventListener('touchstart',(e)=>{e.preventDefault(); active?stop():start();},{passive:false});
  addEventListener('keydown',(e)=>{ if(e.repeat) return; if(e.key.toLowerCase()==='f'){ active?stop():start(); } });
  rate.oninput(()=>{ if(lfoOsc) lfoOsc.frequency.setTargetAtTime(+rate.input.value, audioCtx.currentTime, .02); });
  depth.oninput(()=>{ if(lfoGain) lfoGain.gain.setTargetAtTime(+depth.input.value, audioCtx.currentTime, .02); });
  baseCut.oninput(()=>{ if(lp) lp.frequency.setTargetAtTime(+baseCut.input.value, audioCtx.currentTime, .02); });
  return {desc:'Lesson 4', controls};
}

/********************
 * Slider utilities *
 ********************/
function sliderKV(label, attrs){
  const wrap=document.createElement('div'); wrap.className='slider'; wrap.title=label;
  const input=document.createElement('input'); input.type='range'; Object.assign(input, attrs);
  wrap.append(input); // no visible label text
  globalSliderList.push(input);
  return {wrap,input,oninput:(fn)=> input.addEventListener('input',fn)};
}
function replaceNativeRanges(scope){
  scope.querySelectorAll('input[type=range]').forEach(r=>{
    const vs=document.createElement('div'); vs.className='vslider'; vs.title=r.parentElement?.title||'Slider';
    const fill=document.createElement('div'); fill.className='fill'; vs.append(fill);
    const update=()=>{ const min=+r.min, max=+r.max, val=+r.value; const pct=((val-min)/(max-min))*100; vs.style.setProperty('--val', pct+'%'); };
    r.addEventListener('input', update); update();
    const setFromEvent=(e)=>{ const rect=vs.getBoundingClientRect(); const y=(e.clientY??(e.touches?.[0]?.clientY||0))-rect.top; const pct=1 - Math.min(1,Math.max(0,y/rect.height)); const min=+r.min, max=+r.max; const val=min + pct*(max-min); const step=+r.step||1; r.value=(Math.round(val/step)*step).toString(); r.dispatchEvent(new Event('input',{bubbles:true})); };
    vs.addEventListener('mousedown',e=>{setFromEvent(e)});
    vs.addEventListener('touchstart',e=>{e.preventDefault();setFromEvent(e)},{passive:false});
    r.style.display='none'; r.insertAdjacentElement('afterend', vs);
  });
}

// Q-row keyboard mapping with ×10 step and 300ms interpolation
const sliderKeyMap=[["q","1"],["w","2"],["e","3"],["r","4"],["t","5"],["y","6"],["u","7"],["i","8"]];
function tweenSliderTo(sl, target, ms=300){
  const start=+sl.value; const delta=target-start; const t0=performance.now();
  function step(now){ const p=Math.min(1,(now-t0)/ms); const v=start+delta*p; sl.value=v; sl.dispatchEvent(new Event('input',{bubbles:true})); if(p<1) requestAnimationFrame(step); }
  requestAnimationFrame(step);
}
addEventListener('keydown',(e)=>{
  const k=e.key.toLowerCase();
  // Shift + number: switch divisions
  if(e.shiftKey && /[1-8]/.test(k)){ setDivisions(parseInt(k,10)); return; }
  if(['input','textarea'].includes(document.activeElement?.tagName?.toLowerCase())) return;
  sliderKeyMap.forEach(([dec,inc],idx)=>{
    const sl=globalSliderList[idx]; if(!sl) return; const baseStep=(+sl.step)||((+sl.max-(+sl.min))/100); const step=baseStep*10; // ×10
    if(k===dec){ const v=Math.max(+sl.min, (+sl.value - step)); tweenSliderTo(sl, v, 300); }
    if(k===inc){ const v=Math.min(+sl.max, (+sl.value + step)); tweenSliderTo(sl, v, 300); }
  });
});

// Boot
setDivisions(currentDivisions);
</script>
</body>
</html>
