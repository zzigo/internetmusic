<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hyperphone — Subtractive Synth (Neon Wireframe 1→8)</title>
<style>
  :root{
    --bg:#000; --fg:#eee; --muted:#8aa0b3; --neon:#39d353; --neon2:#58a6ff; --neon3:#ff6ad5; --glass:rgba(255,255,255,0.04);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;overflow:hidden;-webkit-user-select:none;user-select:none}
  header{display:flex;gap:16px;align-items:center;padding:10px 14px;background:linear-gradient(180deg,rgba(255,255,255,.03),transparent);position:sticky;top:0;z-index:10}
  header h1{margin:0;font-size:13px;color:var(--muted)}
  .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .chip{background:transparent;color:var(--fg);padding:6px 10px;border:none;border-radius:8px;cursor:pointer;position:relative}
  .chip[aria-pressed="true"]::after{content:"";position:absolute;inset:-3px;border:1px dashed var(--neon2);border-radius:10px;box-shadow:0 0 18px rgba(88,166,255,.35)}
  .btn{background:transparent;color:var(--fg);padding:8px 12px;border:none;border-radius:10px;cursor:pointer;box-shadow:0 0 0 1px rgba(255,255,255,.12) inset}
  .btn:active{transform:translateY(1px)}
  .grid{display:grid;grid-auto-rows:1fr;gap:10px;padding:10px;height:calc(100% - 58px)}
  .grid.mosaic{grid-auto-flow:dense}
  .panel{background:linear-gradient(180deg,rgba(88,166,255,.05),transparent), var(--glass);border-radius:14px;padding:0;display:flex;flex-direction:column;overflow:hidden;position:relative;box-shadow:0 0 0 1px rgba(255,255,255,.06) inset, 0 0 40px rgba(57,211,83,.05)}
  .panel h2{margin:0;padding:10px 12px;font-size:12px;color:var(--neon2)}
  .panel p{margin:0;padding:0 12px 6px 12px;color:var(--muted);font-size:12px}
  .controls{display:flex;flex-direction:column;gap:10px;padding:12px}
  .topbar{display:flex;gap:12px;align-items:center;padding:8px 12px;background:linear-gradient(90deg,rgba(57,211,83,.05),rgba(255,106,213,.05));box-shadow:0 0 0 1px rgba(255,255,255,.06) inset}
  .keyshelf{display:flex;gap:8px;flex-wrap:wrap;padding:12px}
  .keybtn{width:64px;height:64px;border:none;border-radius:14px;background:transparent;cursor:pointer;position:relative;color:var(--fg);letter-spacing:.5px;font-weight:700}
  .keybtn::before{content:"";position:absolute;inset:0;border:1px dashed rgba(255,255,255,.2);border-radius:14px}
  .keybtn.active::before{border-color:var(--neon);box-shadow:0 0 30px rgba(57,211,83,.35),0 0 0 2px rgba(57,211,83,.25) inset}
  /* Custom slider (neon rail + handle) */
  .vslider{--w:180px;--h:18px;--val:0%;position:relative;width:var(--w);height:var(--h)}
  .vslider .rail{position:absolute;left:0;right:0;top:50%;height:2px;transform:translateY(-50%);background:linear-gradient(90deg,rgba(88,166,255,.4),rgba(255,106,213,.25));box-shadow:0 0 14px rgba(88,166,255,.25)}
  .vslider .fill{position:absolute;left:0;top:50%;height:2px;transform:translateY(-50%);background:var(--neon2);width:var(--val);box-shadow:0 0 10px rgba(88,166,255,.45)}
  .vslider .thumb{position:absolute;top:50%;transform:translate(-50%,-50%);width:12px;height:12px;border-radius:50%;box-shadow:0 0 18px rgba(255,255,255,.45),0 0 0 1px rgba(255,255,255,.2) inset;background:radial-gradient(circle at 30% 30%, #fff, #9fd1ff)}
  .kv{font-size:11px;color:var(--muted)}
  .pad{border:1px dashed rgba(255,255,255,.15);height:120px;border-radius:12px;background:repeating-linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.05) 8px, transparent 8px, transparent 16px);display:grid;place-items:center;color:var(--muted);font-size:12px;user-select:none;touch-action:none;cursor:crosshair;margin:12px}
  .meter{height:6px;background:rgba(255,255,255,.06);border-radius:6px;overflow:hidden;width:240px;margin:8px 12px}
  .meter>div{height:100%;width:0%;background:linear-gradient(90deg, var(--neon), var(--neon2));transition:width .08s linear}
</style>
</head>
<body>
  <header>
    <h1>Hyperphone — Subtractive Synth (incremental 1→8)</h1>
    <div class="row" id="divisionBar" aria-label="Choose screen divisions">
      <span class="kv">Divisions:</span>
      <!-- chips injected by JS -->
    </div>
    <button id="fullscreenBtn" class="btn" title="Toggle Fullscreen (double‑click anywhere)">Fullscreen</button>
    <span class="kv">Keys: [Space]=Noise (L1), [A/S/D]=L2/L3, [F]=L4 toggle</span>
  </header>

  <main class="grid" id="grid"></main>

<script>
/***************************
 * AUDIO ENGINE PRIMITIVES *
 ***************************/
let audioCtx; let masterGain; let analyser; let meterRAF;
async function ensureAudio(){
  if(audioCtx && audioCtx.state!=='closed'){ if(audioCtx.state==='suspended') await audioCtx.resume(); return; }
  audioCtx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
  masterGain = audioCtx.createGain(); masterGain.gain.value=0.9;
  analyser = audioCtx.createAnalyser(); analyser.fftSize=2048;
  masterGain.connect(analyser).connect(audioCtx.destination);
}
function createWhiteNoiseBuffer(ctx){
  const length = ctx.sampleRate*2; const buffer=ctx.createBuffer(2,length,ctx.sampleRate);
  for(let ch=0; ch<2; ch++){ const data=buffer.getChannelData(ch); for(let i=0;i<length;i++){ data[i]=Math.random()*2-1; } }
  return buffer;
}
function makeNoiseSource(){
  const source=audioCtx.createBufferSource(); source.buffer=createWhiteNoiseBuffer(audioCtx); source.loop=true; const trim=audioCtx.createGain(); trim.gain.value=1; source.connect(trim); return {source,outlet:trim};
}
function makeADSR({attack=.01,decay=.1,sustain=.7,release=.2}={}){
  const vca=audioCtx.createGain(); vca.gain.value=0;
  const gateOn=()=>{ const now=audioCtx.currentTime; vca.gain.cancelScheduledValues(now); vca.gain.setValueAtTime(vca.gain.value,now); vca.gain.linearRampToValueAtTime(1, now+attack); vca.gain.linearRampToValueAtTime(sustain, now+attack+decay); };
  const gateOff=()=>{ const now=audioCtx.currentTime; vca.gain.cancelScheduledValues(now); vca.gain.setValueAtTime(vca.gain.value,now); vca.gain.linearRampToValueAtTime(0, now+release); };
  return {node:vca, gateOn, gateOff};
}
function makeFilter({type='lowpass',cutoff=1200,Q=0.0001}={}){ const biq=audioCtx.createBiquadFilter(); biq.type=type; biq.frequency.value=cutoff; biq.Q.value=Q; return biq; }
function wireSimpleMeter(barEl){
  const data=new Uint8Array(analyser.frequencyBinCount);
  function loop(){ analyser.getByteTimeDomainData(data); let sum=0; for(let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum+=v*v; } const rms=Math.sqrt(sum/data.length); const pct=Math.min(100,Math.max(0,Math.round(rms*220))); barEl.style.width=pct+'%'; meterRAF=requestAnimationFrame(loop); }
  cancelAnimationFrame(meterRAF); loop();
}

/***********************
 * UI / LAYOUT CONTROL *
 ***********************/
const grid=document.getElementById('grid');
const divisionBar=document.getElementById('divisionBar');
const fullscreenBtn=document.getElementById('fullscreenBtn');
let currentDivisions=3;
let globalSliderList=[]; // ordered sliders for Q-row control
for(let n=1;n<=8;n++){ const chip=document.createElement('button'); chip.className='chip'; chip.textContent=n; chip.setAttribute('aria-pressed', String(n===currentDivisions)); chip.addEventListener('click',()=>setDivisions(n)); divisionBar.appendChild(chip); }
function setDivisions(n){
  currentDivisions=n; [...divisionBar.querySelectorAll('.chip')].forEach((c,i)=>c.setAttribute('aria-pressed', String(i+1===n)));
  const cols=Math.min(4,n); grid.classList.toggle('mosaic',[3,5,6,7].includes(n)); grid.style.gridTemplateColumns = ([3,5,6,7].includes(n)) ? '2.2fr 1.2fr 1.6fr 1fr' : `repeat(${cols},1fr)`; renderPanels(n);
  if([3,5,6,7].includes(n)){
    [...grid.children].forEach((el,idx)=>{ el.style.gridColumn=''; el.style.gridRow=''; if(n===3 && idx===1) el.style.gridRow='span 2'; if(n===5 && (idx===0||idx===3)) el.style.gridColumn='span 2'; if(n===6 && (idx===2||idx===5)) el.style.gridRow='span 2'; if(n===7 && (idx===1||idx===4)) el.style.gridColumn='span 2'; });
  }
}
fullscreenBtn.addEventListener('click', toggleFullscreen); addEventListener('dblclick', toggleFullscreen);
function toggleFullscreen(){ if(!document.fullscreenElement){ document.documentElement.requestFullscreen?.(); } else { document.exitFullscreen?.(); } }

/****************
 * PANEL RENDER *
 ****************/
function renderPanels(n){
  grid.innerHTML=''; globalSliderList=[];
  for(let i=1;i<=n;i++){
    const panel=document.createElement('section'); panel.className='panel';
    const h=document.createElement('h2'); h.textContent=`Lesson ${i}`; const p=document.createElement('p');
    const content=buildLesson(i); p.textContent=content.desc;
    const topbar=document.createElement('div'); topbar.className='topbar';
    const keyshelf=document.createElement('div'); keyshelf.className='keyshelf';
    // move sliders into topbar (we use sliderKV so ranges already in wraps)
    content.controls.querySelectorAll('.slider').forEach(s=>topbar.appendChild(s));
    [...content.controls.childNodes].forEach(n=>{ if(!topbar.contains(n)) keyshelf.appendChild(n); });
    // convert native ranges in topbar to neon controls
    replaceNativeRanges(topbar);
    panel.append(h,p,topbar,keyshelf);
    if(i===1){ const meter=document.createElement('div'); meter.className='meter'; const fill=document.createElement('div'); meter.appendChild(fill); panel.appendChild(meter); content.onFirstStart=()=>wireSimpleMeter(fill); }
    grid.appendChild(panel);
  }
}

/***********************
 * LESSON DEFINITIONS  *
 ***********************/
function buildLesson(idx){
  switch(idx){
    case 1: return lesson1_basicNoise();
    case 2: return lesson2_lowpassAndTwoKeys();
    case 3: return lesson3_adsrEnvelope();
    case 4: return lesson4_lfoOnCutoff();
    case 5: return stubLesson('Multimode filter & resonance sweep');
    case 6: return stubLesson('Serial vs parallel filtering (HP+LP)');
    case 7: return stubLesson('Noise color morphing (white/pink/brown)');
    case 8: return stubLesson('Keyboard mapping + touch velocity');
    default: return stubLesson('Coming next');
  }
}
function stubLesson(title){ const controls=document.createElement('div'); controls.className='controls'; const span=document.createElement('span'); span.className='kv'; span.textContent=`Placeholder: ${title}`; controls.appendChild(span); return {desc:'Work in progress. Use earlier lessons for now.', controls}; }

// L1 — Basic white noise (press&hold)
function lesson1_basicNoise(){
  const controls=document.createElement('div'); controls.className='controls';
  const bigKey=document.createElement('button'); bigKey.className='keybtn'; bigKey.textContent='NOISE';
  let started=false; let current=null; function startNoise(){ ensureAudio().then(()=>{ if(!started){ started=true; lesson1.onFirstStart && lesson1.onFirstStart(); } if(current) return; const {source,outlet}=makeNoiseSource(); outlet.connect(masterGain); source.start(); current={source,outlet}; bigKey.classList.add('active'); }); }
  function stopNoise(){ if(!current) return; try{current.source.stop();}catch{} current.outlet.disconnect(); current=null; bigKey.classList.remove('active'); }
  bigKey.addEventListener('mousedown',startNoise); bigKey.addEventListener('mouseup',stopNoise); bigKey.addEventListener('mouseleave',stopNoise);
  bigKey.addEventListener('touchstart',(e)=>{e.preventDefault();startNoise();},{passive:false}); bigKey.addEventListener('touchend',stopNoise);
  addEventListener('keydown',(e)=>{ if(e.code==='Space') startNoise(); }); addEventListener('keyup',(e)=>{ if(e.code==='Space') stopNoise(); });
  const controlsWrap=document.createElement('div'); controlsWrap.className='controls'; controlsWrap.appendChild(bigKey);
  return (window.lesson1={desc:'Press and hold to emit white noise; release to silence. This is the raw source we will later sculpt with filters and envelopes.', controls:controlsWrap, onFirstStart:null});
}

// L2 — Lowpass + compare two triggers (A darker / S brighter)
function lesson2_lowpassAndTwoKeys(){
  const controls=document.createElement('div'); controls.className='controls';
  const keyA=document.createElement('button'); keyA.className='keybtn'; keyA.textContent='A'; keyA.title='Key A or click: lowpass noise';
  const keyS=document.createElement('button'); keyS.className='keybtn'; keyS.textContent='S'; keyS.title='Key S or click: brighter (higher cutoff)';
  const cutoff=sliderKV('Cutoff', {min:100,max:8000,step:1,value:1200});
  const q=sliderKV('Resonance', {min:0.0001,max:30,step:0.0001,value:0.0001});
  let activeA=null, activeS=null;
  function trigger(which, brighter){ ensureAudio().then(()=>{ const {source,outlet}=makeNoiseSource(); const lp=makeFilter({type:'lowpass', cutoff: brighter ? Math.max(1500, parseFloat(cutoff.input.value)*2) : parseFloat(cutoff.input.value), Q: parseFloat(q.input.value)}); outlet.connect(lp).connect(masterGain); source.start(); if(which==='A'){activeA={source,outlet,lp}; keyA.classList.add('active');} else {activeS={source,outlet,lp}; keyS.classList.add('active');} }); }
  function release(which){ const act=(which==='A')?activeA:activeS; if(!act) return; try{act.source.stop();}catch{} act.outlet.disconnect(); act.lp.disconnect(); if(which==='A'){activeA=null; keyA.classList.remove('active');} else {activeS=null; keyS.classList.remove('active');} }
  keyA.addEventListener('mousedown',()=>trigger('A',false)); keyA.addEventListener('mouseup',()=>release('A')); keyA.addEventListener('mouseleave',()=>release('A'));
  keyA.addEventListener('touchstart',(e)=>{e.preventDefault();trigger('A',false)},{passive:false}); keyA.addEventListener('touchend',()=>release('A'));
  keyS.addEventListener('mousedown',()=>trigger('S',true)); keyS.addEventListener('mouseup',()=>release('S')); keyS.addEventListener('mouseleave',()=>release('S'));
  keyS.addEventListener('touchstart',(e)=>{e.preventDefault();trigger('S',true)},{passive:false}); keyS.addEventListener('touchend',()=>release('S'));
  addEventListener('keydown',(e)=>{ if(e.repeat) return; const k=e.key.toLowerCase(); if(k==='a') trigger('A',false); if(k==='s') trigger('S',true); });
  addEventListener('keyup',(e)=>{ const k=e.key.toLowerCase(); if(k==='a') release('A'); if(k==='s') release('S'); });
  cutoff.oninput(()=>{ if(activeA) activeA.lp.frequency.value=+cutoff.input.value; if(activeS) activeS.lp.frequency.value=Math.max(1500, +cutoff.input.value*2); });
  q.oninput(()=>{ if(activeA) activeA.lp.Q.value=+q.input.value; if(activeS) activeS.lp.Q.value=+q.input.value; });
  const controlsWrap=document.createElement('div'); controlsWrap.className='controls'; controlsWrap.append(keyA,keyS,cutoff.wrap,q.wrap); return {desc:'Introduce a low‑pass filter. Press A for a darker noise; S for a brighter variant (twice the cutoff). Adjust cutoff and resonance to hear spectral sculpting.', controls:controlsWrap};
}

// L3 — ADSR envelope on amplitude (D to gate)
function lesson3_adsrEnvelope(){
  const controls=document.createElement('div'); controls.className='controls';
  const keyD=document.createElement('button'); keyD.className='keybtn'; keyD.textContent='D'; keyD.title='Gate with ADSR on amplitude';
  const A=sliderKV('Attack', {min:0.001,max:1.0,step:0.001,value:0.02});
  const D=sliderKV('Decay',  {min:0.001,max:2.0,step:0.001,value:0.2});
  const S=sliderKV('Sustain',{min:0.0,max:1.0,step:0.001,value:0.6});
  const R=sliderKV('Release',{min:0.001,max:2.0,step:0.001,value:0.3});
  const cutoff=sliderKV('LP Cutoff',{min:200,max:8000,step:1,value:1800});
  let env, active=null;
  function gateOn(){ ensureAudio().then(()=>{ if(active) return; const {source,outlet}=makeNoiseSource(); const lp=makeFilter({type:'lowpass',cutoff:+cutoff.input.value,Q:0.0001}); env=makeADSR({attack:+A.input.value,decay:+D.input.value,sustain:+S.input.value,release:+R.input.value}); outlet.connect(lp).connect(env.node).connect(masterGain); source.start(); env.gateOn(); active={source,outlet,lp}; keyD.classList.add('active'); }); }
  function gateOff(){ if(!active) return; env.gateOff(); const stopAt=audioCtx.currentTime + +R.input.value + 0.05; active.source.stop(stopAt); setTimeout(()=>{ try{active.outlet.disconnect(); active.lp.disconnect();}catch{} active=null; keyD.classList.remove('active'); }, (+R.input.value+0.1)*1000); }
  keyD.addEventListener('mousedown',gateOn); keyD.addEventListener('mouseup',gateOff); keyD.addEventListener('mouseleave',gateOff);
  keyD.addEventListener('touchstart',(e)=>{e.preventDefault();gateOn();},{passive:false}); keyD.addEventListener('touchend',gateOff);
  addEventListener('keydown',(e)=>{ if(e.repeat) return; if(e.key.toLowerCase()==='d') gateOn(); }); addEventListener('keyup',(e)=>{ if(e.key.toLowerCase()==='d') gateOff(); });
  cutoff.oninput(()=>{ if(active) active.lp.frequency.value=+cutoff.input.value; });
  const controlsWrap=document.createElement('div'); controlsWrap.className='controls'; controlsWrap.append(keyD,A.wrap,D.wrap,S.wrap,R.wrap,cutoff.wrap); return {desc:'Add an ADSR envelope on amplitude. Press D (or touch) to gate. Adjust A/D/S/R to hear percussive vs pad‑like shapes. A simple low‑pass stays in the path.', controls:controlsWrap};
}

// L4 — LFO modulating filter cutoff (F toggles)
function lesson4_lfoOnCutoff(){
  const controls=document.createElement('div'); controls.className='controls';
  const play=document.createElement('button'); play.className='keybtn'; play.textContent='LFO'; play.title='Toggle tone with LFO on cutoff (F)';
  const rate=sliderKV('LFO Rate',{min:0.1,max:20,step:0.01,value:5});
  const depth=sliderKV('Depth',{min:50,max:6000,step:1,value:1200});
  const baseCut=sliderKV('Base Cutoff',{min:100,max:8000,step:1,value:800});
  controls.append(play, rate.wrap, depth.wrap, baseCut.wrap);
  let active=null, lfoOsc=null, lfoGain=null, lp=null;
  function start(){ ensureAudio().then(()=>{ if(active) return; const {source,outlet}=makeNoiseSource(); lp=makeFilter({type:'lowpass',cutoff:+baseCut.input.value,Q:.0001}); lfoOsc=audioCtx.createOscillator(); lfoOsc.type='sine'; lfoOsc.frequency.value=+rate.input.value; lfoGain=audioCtx.createGain(); lfoGain.gain.value=+depth.input.value; lfoOsc.connect(lfoGain).connect(lp.frequency); outlet.connect(lp).connect(masterGain); lfoOsc.start(); source.start(); active={source,outlet}; play.classList.add('active'); }); }
  function stop(){ if(!active) return; try{active.source.stop(); lfoOsc.stop();}catch{} try{active.outlet.disconnect(); lp.disconnect(); lfoGain.disconnect();}catch{} active=null; lfoOsc=null; lfoGain=null; lp=null; play.classList.remove('active'); }
  play.addEventListener('mousedown',()=> active?stop():start()); play.addEventListener('touchstart',(e)=>{e.preventDefault(); active?stop():start();},{passive:false});
  addEventListener('keydown',(e)=>{ if(e.repeat) return; if(e.key.toLowerCase()==='f'){ active?stop():start(); } });
  rate.oninput(()=>{ if(lfoOsc) lfoOsc.frequency.setTargetAtTime(+rate.input.value, audioCtx.currentTime, .02); });
  depth.oninput(()=>{ if(lfoGain) lfoGain.gain.setTargetAtTime(+depth.input.value, audioCtx.currentTime, .02); });
  baseCut.oninput(()=>{ if(lp) lp.frequency.setTargetAtTime(+baseCut.input.value, audioCtx.currentTime, .02); });
  return {desc:'Introduce slow modulation. A sine LFO moves the filter cutoff around a base value, creating motion from static noise. Press F to toggle.', controls};
}

/********************
 * Slider utilities *
 ********************/
function sliderKV(label, attrs){
  const wrap=document.createElement('div'); wrap.className='slider';
  const title=document.createElement('span'); title.className='kv'; title.textContent=label;
  const input=document.createElement('input'); input.type='range'; Object.assign(input, attrs);
  const val=document.createElement('span'); val.className='kv'; val.textContent=fmtVal(input);
  input.addEventListener('input', ()=> val.textContent=fmtVal(input));
  wrap.append(title,input,val);
  globalSliderList.push(input);
  return {wrap,input,oninput:(fn)=> input.addEventListener('input',fn)};
}
function fmtVal(i){ return (Number(i.value).toFixed( (i.step+'' ).includes('.') ? (i.step+'').split('.')[1].length : 0)) }
function replaceNativeRanges(scope){
  scope.querySelectorAll('input[type=range]').forEach(r=>{
    const vs=document.createElement('div'); vs.className='vslider';
    const rail=document.createElement('div'); rail.className='rail';
    const fill=document.createElement('div'); fill.className='fill';
    const thumb=document.createElement('div'); thumb.className='thumb';
    vs.append(rail,fill,thumb);
    const update=()=>{ const min=+r.min, max=+r.max, val=+r.value; const pct=((val-min)/(max-min))*100; vs.style.setProperty('--val', pct+'%'); fill.style.width=pct+'%'; thumb.style.left=pct+'%'; };
    r.addEventListener('input', update); update();
    const setFromEvent=(e)=>{ const rect=vs.getBoundingClientRect(); const x=(e.clientX??(e.touches?.[0]?.clientX||0))-rect.left; const pct=Math.min(1,Math.max(0,x/rect.width)); const min=+r.min, max=+r.max; const val=min + pct*(max-min); const step=+r.step||1; r.value=(Math.round(val/step)*step).toString(); r.dispatchEvent(new Event('input',{bubbles:true})); };
    vs.addEventListener('mousedown',e=>{setFromEvent(e)});
    vs.addEventListener('touchstart',e=>{e.preventDefault();setFromEvent(e)},{passive:false});
    r.style.display='none'; r.insertAdjacentElement('afterend', vs);
  });
}

// Q-row keyboard mapping: q/1, w/2, e/3, r/4, t/5, y/6, u/7, i/8
const sliderKeyMap=[["q","1"],["w","2"],["e","3"],["r","4"],["t","5"],["y","6"],["u","7"],["i","8"]];
addEventListener('keydown',(e)=>{
  const k=e.key.toLowerCase(); if(['input','textarea'].includes(document.activeElement?.tagName?.toLowerCase())) return;
  sliderKeyMap.forEach(([dec,inc],idx)=>{ const sl=globalSliderList[idx]; if(!sl) return; const step=(+sl.step)||((+sl.max-(+sl.min))/100); const fast=e.shiftKey?5:1; if(k===dec){ const v=Math.max(+sl.min,(+sl.value - step*fast)); sl.value=v; sl.dispatchEvent(new Event('input',{bubbles:true})); } if(k===inc){ const v=Math.min(+sl.max,(+sl.value + step*fast)); sl.value=v; sl.dispatchEvent(new Event('input',{bubbles:true})); } });
});

// Boot
setDivisions(currentDivisions);
</script>
</body>
</html>
