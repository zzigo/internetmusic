<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>QWERTY Piano Sampler (8 'C' roots, pitch via playbackRate)</title>
<style>
  :root { --whiteW: 48px; --whiteH: 170px; --blackW: 28px; --blackH: 108px; }
  body { font-family: system-ui, Arial, sans-serif; background:#f0f0f0; margin:0; padding:24px; }
  .piano-container { max-width:900px; margin:0 auto; background:#fff; border-radius:10px; padding:20px; box-shadow:0 2px 12px rgba(0,0,0,.08); }
  h1 { margin:0 0 8px 0; font-size:20px; }
  .octave-controls { display:flex; align-items:center; gap:12px; margin:10px 0 6px 0; }
  button { padding:8px 10px; border:1px solid #888; border-radius:6px; background:#fafafa; cursor:pointer; }
  #keyboard { position:relative; height:200px; display:block; margin:24px auto 12px; width: calc(var(--whiteW) * 8 + 20px); }
  .white { display:inline-block; vertical-align:top; width:var(--whiteW); height:var(--whiteH); background:#fff; border:1px solid #333; border-bottom-left-radius:6px; border-bottom-right-radius:6px; box-sizing:border-box; position:relative; }
  .black { position:absolute; width:var(--blackW); height:var(--blackH); background:#111; color:#fff; border-radius:0 0 4px 4px; z-index:10; }
  .key-label { position:absolute; bottom:8px; left:0; right:0; text-align:center; font-size:12px; white-space:pre-line; pointer-events:none; }
  .active.white { background:#4CAF50; color:#fff; }
  .active.black { background:#2E7D32; }
  .instructions { background:#eef7ff; padding:10px; border-radius:6px; font-size:14px; }
  .status { margin-top:6px; color:#666; font-style:italic; font-size:13px; }
</style>
</head>
<body>
<div class="piano-container">
  <h1>QWERTY Piano Sampler</h1>
  <div class="octave-controls">
    <button id="octave-down">Octave Down (&larr;)</button>
    <span id="current-octave">Octave: 4</span>
    <button id="octave-up">Octave Up (&rarr;)</button>
  </div>
  <div id="keyboard"></div>
  <div class="instructions">
    1st Octave (keys Z-M): C, C#, D, D#, E, F, F#, G, G#, A, A#, B<br>
    2nd Octave (keys Q-U): C, C#, D, D#, E, F, F#, G, G#, A, A#, B<br>
    Arrows Left/Right to change octave.
  </div>
  <div class="status" id="status">Load your 8 'C' mp3s, then press a key</div>
</div>

<script>
/* ===================== User-configurable roots ===================== */
/* Put your 8 C mp3 files here. Filenames must include pitch like C1, C2, etc. */
const SAMPLE_FILES = ['C1.mp3', 'C2.mp3', 'C3.mp3', 'C4.mp3', 'C5.mp3', 'C6.mp3', 'C7.mp3', 'C8.mp3'];
/* If files live elsewhere, set BASE_PATH accordingly. */
const BASE_PATH = (location.protocol === 'file:') ? '../inc/' : '../inc/';

/* ===================== Note tables ===================== */
const NOTE_INDEX = { 'C':0,'C#':1,'Db':1,'D':2,'D#':3,'Eb':3,'E':4,'Fb':4,'E#':5,'F':5,'F#':6,'Gb':6,'G':7,'G#':8,'Ab':8,'A':9,'A#':10,'Bb':10,'B':11,'Cb':11,'B#':0 };
const NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
function midiFromName(s){ // e.g. "F#4"
  const m = /^([A-G](?:#|b)?)(-?\d+)$/.exec(s);
  if(!m) return null;
  const n = NOTE_INDEX[m[1]];
  const o = parseInt(m[2],10);
  return 12*(o+1)+n; // MIDI: C-1=0
}
function nameFromMidi(m){
  const n = m%12; const o = Math.floor(m/12)-1;
  return NAMES[(n+12)%12]+o;
}

/* ===================== Keyboard mapping ===================== */
const keyToNote = {
  'z': [0, 0],  // C
  's': [0, 1],  // C#
  'x': [0, 2],  // D
  'd': [0, 3],  // D#
  'c': [0, 4],  // E
  'v': [0, 5],  // F
  'g': [0, 6],  // F#
  'b': [0, 7],  // G
  'h': [0, 8],  // G#
  'n': [0, 9],  // A
  'j': [0, 10], // A#
  'm': [0, 11], // B
  'q': [1, 0],  // C +1 octave
  '2': [1, 1],  // C# +1 octave
  'w': [1, 2],  // D +1 octave
  '3': [1, 3],  // D# +1 octave
  'e': [1, 4],  // E +1 octave
  'r': [1, 5],  // F +1 octave
  '5': [1, 6],  // F# +1 octave
  't': [1, 7],  // G +1 octave
  '6': [1, 8],  // G# +1 octave
  'y': [1, 9],  // A +1 octave
  '7': [1, 10], // A# +1 octave
  'u': [1, 11], // B +1 octave
};
let currentOctave = 4;
let audioContext;
const roots = []; // {name, midi, buffer}
const activeNotes = new Map(); // key -> { source, gain }

/* ===================== Build keyboard ===================== */
const whiteOrder = ['C','D','E','F','G','A','B','C'];
const blackBetween = { 0:'C#',1:'D#',3:'F#',4:'G#',5:'A#' }; // index between white[i] and white[i+1]
function buildKeyboard(){
  const kb = document.getElementById('keyboard');
  kb.innerHTML='';
  const whiteEls = [];
  // This part is not updated to reflect the new key mapping visually,
  // as it requires significant changes and was not explicitly requested.
  // The old visual layout is maintained.
  for(let i=0;i<whiteOrder.length;i++){
    const w = document.createElement('div');
    w.className='white key';
    w.dataset.kind='white';
    w.dataset.key = ['a','s','d','f','g','h','j','k'][i]; // Old mapping for visual purposes
    const lab = document.createElement('div');
    lab.className='key-label';
    lab.textContent = `${whiteOrder[i]}`;
    w.appendChild(lab);
    kb.appendChild(w);
    whiteEls.push(w);
  }
  const bw = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--blackW'));
  for(const iStr of Object.keys(blackBetween)){
    const i = parseInt(iStr,10);
    const leftA = whiteEls[i].offsetLeft;
    const leftB = whiteEls[i+1].offsetLeft;
    const center = (leftA + leftB + whiteEls[i+1].offsetWidth*0)/2;
    const b = document.createElement('div');
    b.className='black key';
    b.style.left = (center - bw/2) + 'px';
    b.style.top = '0px';
    b.dataset.kind='black';
    const lab = document.createElement('div');
    lab.className='key-label';
    lab.textContent = `${blackBetween[i]}`;
    b.appendChild(lab);
    kb.appendChild(b);
  }
  window.addEventListener('resize', ()=>buildKeyboard());
}

/* ===================== Audio loading ===================== */
async function initAudio(){
  audioContext = new (window.AudioContext||window.webkitAudioContext)();
  await loadRoots();
  buildKeyboard();
  setStatus(roots.length ? 'Ready. Play with keyboard.' : 'No samples loaded.');
}
async function loadRoots(){
  const loads = SAMPLE_FILES.map(async (file)=>{
    const url = BASE_PATH + file;
    try{
      const res = await fetch(url);
      if(!res.ok) { console.warn('Missing:', url); return; }
      const arr = await res.arrayBuffer();
      const buf = await audioContext.decodeAudioData(arr);
      const m = /([A-G](?:#|b)?-?\d)/.exec(file);
      if(!m){ console.warn('Name missing pitch:', file); return; }
      const name = m[1];
      const midi = midiFromName(name);
      if(midi==null){ console.warn('Unparsable pitch:', file); return; }
      roots.push({name, midi, buffer:buf});
      console.log('Loaded', name, file);
    }catch(e){ console.warn('Error loading', url, e); }
  });
  await Promise.all(loads);
  roots.sort((a,b)=>a.midi-b.midi);
}

/* ===================== Playback ===================== */
function midiFromTarget(semiIndex, octave){
  return 12*(octave+1) + semiIndex;
}
function pickNearestRoot(targetMIDI){
  if (roots.length === 0) return null;

  const targetOctave = Math.floor(targetMIDI / 12) - 1;
  const noteIndex = targetMIDI % 12;
  const sampleOctave = noteIndex >= 8 ? targetOctave + 1 : targetOctave;
  const sampleName = 'C' + sampleOctave;

  let best = roots.find(r => r.name === sampleName);

  if (!best) {
    if (targetMIDI < roots[0].midi) {
      best = roots[0];
    } else {
      best = roots[roots.length - 1];
    }
  }
  return best;
}
function playWithRoot(root, targetMIDI){
  const diff = targetMIDI - root.midi;
  const rate = Math.pow(2, diff/12);
  const now = audioContext.currentTime;

  const src = audioContext.createBufferSource();
  src.buffer = root.buffer;
  src.playbackRate.value = rate;

  const hp = audioContext.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=18; hp.Q.value=0.707;
  const lp = audioContext.createBiquadFilter(); lp.type='lowpass';
  const baseCut = 16000;
  const cut = Math.max(2200, baseCut/Math.max(1, rate));
  lp.frequency.setValueAtTime(cut, now); lp.Q.value=0.707;

  const g = audioContext.createGain();
  const attack=0.004, sustain=1.0;
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(sustain, now+attack);

  src.connect(hp); hp.connect(lp); lp.connect(g); g.connect(audioContext.destination);

  const startOffset = findNearZero(src.buffer, 2048) / src.buffer.sampleRate;
  src.start(now, startOffset);

  return {rate, diff, source: src, gain: g};
}
function findNearZero(buf, windowSamples){
  const ch = buf.getChannelData(0);
  let bestIdx = 0, bestVal = 1e9;
  const N = Math.min(ch.length, windowSamples);
  for(let i=1;i<N;i++){
    const v = Math.abs(ch[i]);
    if(v < bestVal){ bestVal = v; bestIdx = i; if(v<1e-5) break; }
  }
  return bestIdx;
}

/* ===================== Interaction ===================== */
function setStatus(s){ const el=document.getElementById('status'); el.textContent=s; }
function highlightKey(k, on=true){
  // This function might not highlight correctly as the visual keyboard is not updated.
  const el = document.querySelector(`[data-key="${k}"]`);
  if(el){ el.classList.toggle('active', on); }
}

function triggerKeyOn(k){
  if(!audioContext) return;
  if(audioContext.state==='suspended') audioContext.resume();
  if (activeNotes.has(k)) return; // Note already playing

  const map = keyToNote[k]; if(!map) return;
  const [octOff, semi] = map;
  const targetOct = Math.max(1, Math.min(8, currentOctave + octOff));
  const targetMIDI = midiFromTarget(semi, targetOct);

  if(!roots.length){ setStatus('No samples loaded.'); return; }

  const root = pickNearestRoot(targetMIDI);
  if (!root) {
    setStatus('Could not find a suitable sample for this note.');
    return;
  }
  const playback = playWithRoot(root, targetMIDI);
  activeNotes.set(k, playback);
  setStatus(`Note ${nameFromMidi(targetMIDI)} from ${root.name} Δ=${playback.diff>=0?'+':''}${playback.diff} st (rate ${playback.rate.toFixed(3)})`);
  highlightKey(k, true);
}

function triggerKeyOff(k){
  if (!activeNotes.has(k)) return;
  const { source, gain } = activeNotes.get(k);
  const now = audioContext.currentTime;
  const releaseTime = 1.5; // 1.5s release
  gain.gain.cancelScheduledValues(now);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + releaseTime);
  // source.stop(now + releaseTime); // Let sample play to end
  activeNotes.delete(k);
  highlightKey(k, false);
}

document.addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  if (k === 'arrowleft') { currentOctave=Math.max(1,currentOctave-1); document.getElementById('current-octave').textContent=`Octave: ${currentOctave}`; setStatus(`Octave ${currentOctave}`); return; }
  if (k === 'arrowright') { currentOctave=Math.min(8,currentOctave+1); document.getElementById('current-octave').textContent=`Octave: ${currentOctave}`; setStatus(`Octave ${currentOctave}`); return; }
  if (keyToNote[k]){
    e.preventDefault();
    triggerKeyOn(k);
  }
});
document.addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();
  if (keyToNote[k]){
    e.preventDefault();
    triggerKeyOff(k);
  }
});

/* ===================== Boot ===================== */
window.addEventListener('load', initAudio);
</script>
</body>
</html>